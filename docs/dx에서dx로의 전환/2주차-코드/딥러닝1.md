---
layout: default
title: 딥러닝1.py
parent: 2주차 코드
grand_parent: DX 전환
nav_order: 4
---

# 딥러닝1.py

MNIST 손글씨 분류 - 기초 딥러닝

## 핵심 개념
- MNIST 데이터셋 활용
- Sequential 모델 구축
- sparse_categorical_crossentropy (원핫인코딩 불필요)
- 데이터 정규화 (0~255 → 0~1)

```python
from tensorflow.keras.datasets import mnist  #우편번호 분리하려고 만든 데이테셋
#전체 7만개
import tensorflow as  tf
tf.random.set_seed(1234) #시드고정하기

#교재의 데이터 분석 순서 정리하기
#1.제공하는 데이터 불러오기
(train_images, train_labels), (test_images, test_labels) = mnist.load_data()

#이미 데이터가 만들어져 있다. 60000개의 훈련데이터셋, 10000개의 테스트셋
#신경망의 이미지는 3차원을 2차원으로 바꾸서 인식
#28 by 28 이미지가 60000 개가 있음
print( train_images.shape)  #이미지의 크기와 타입을 확인해보자
print(type(train_images))

print( train_labels.shape)
print( train_labels[:10])

#2.딥러닝 모델을 만든다
from tensorflow import keras
from tensorflow.keras import models
from tensorflow.keras import layers

#신경망 모델(네트워크) 만들기
model = keras.Sequential([
#층을 추가한다. - 입력층과 출력층 두개는 추가해야 한다
    layers.Dense(64, activation="relu"),
    layers.Dense(10, activation="softmax")
])

#sgd(경사하강법을 업그레이드함) rmsprop
#진동이 크지 않고 수렴 속도가 빠름.
#RNN에 적합합

#categorical_crossentropy : 원핫인코딩 필요함
#sparse_categorical_crossentropy : 정수형 레이블을 직접 사용할 때
model.compile( optimizer="rmsprop",
                 loss="sparse_categorical_crossentropy",
                 metrics=['accuracy'])


#입력은 2차원형태이어야 한다  3차원 -> 2차원으로 벼경한다
train_images = train_images.reshape( (60000, 28*28) )
#딥러닝은 스케일링 필요 - normalize 0~1사이에 머무르게 한다
train_images = train_images.astype('float32')/255

#다중이미지분류 - 딥러닝은 반드시 원핫인코딩으로 해서 전달해야 한다
#손실함수로 categorical_crossentropy 사용할때 - 이제 원핫인코딩 필요없음
# from tensorflow.keras.utils import to_categorical #케라스가 제공하는 원핫인코딩
# train_labels = to_categorical(train_labels)
# test_labels = to_categorical(test_labels)

test_images = test_images.reshape( (10000, 28*28))
test_images = test_images/255

#학습시작
hist =  model.fit (  train_images,
               train_labels,
               epochs=5, #총 학습횟수
               batch_size=128 #데이터가 클때 학습한번하자고
                             #모든데이터한번에 메모리에
                             #로딩 못함, batch_size 에서
                             #준만큼 읽어와서 실행
         )

train_loss, train_acc = model.evaluate( train_images, train_labels)
print("훈련셋 손실 {} 정확도 {}".format(train_loss, train_acc))
test_loss, test_acc = model.evaluate( test_images, test_labels)
print("테스트셋 손실 {} 정확도 {}".format(test_loss, test_acc))
```
