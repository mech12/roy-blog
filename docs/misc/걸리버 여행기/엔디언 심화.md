---
layout: default
title: 엔디언 심화
parent: 걸리버 여행기 원작에 대해
grand_parent: 잡동사니
nav_order: 2
---

# 엔디언(Endianness) 심화 가이드

걸리버 여행기의 빅엔디언/리틀엔디언 풍자에서 유래한 컴퓨터 용어를 깊이 있게 살펴봅니다.

---

## 1. Big-endian / Little-endian의 CPU별 역사

### 초기 컴퓨터 시대 (1960~1970년대)

| 시스템 | 엔디언 | 출시 연도 | 비고 |
|--------|--------|-----------|------|
| IBM System/360 | Big-endian | 1964 | 메인프레임의 표준 |
| PDP-11 | Little-endian | 1970 | DEC의 선택 |
| PDP-10 | Big-endian | 1966 | 36비트 워드 |

### 1980년대: 분열의 시대

Danny Cohen이 1980년 논문을 쓸 당시, 컴퓨터 세계는 혼란 그 자체였습니다.

```
Big-endian 진영          Little-endian 진영
─────────────────        ─────────────────
IBM 메인프레임            Intel 8080/8086
Motorola 68000           DEC VAX
Sun SPARC
```

**왜 이런 분열이 생겼나?**

- **Big-endian 지지자**: "사람이 읽는 순서와 같다. 0x1234는 12 34로 저장되어야 자연스럽다."
- **Little-endian 지지자**: "하위 바이트가 낮은 주소에 있으면 타입 캐스팅이 쉽다. 32비트 → 16비트 변환 시 주소 변경 불필요."

### 주요 CPU 아키텍처별 엔디언 역사

#### Intel x86 (Little-endian)

```
1978: 8086 출시 - Little-endian 채택
이유: 8비트 8080과의 호환성 + 하드웨어 설계 단순화

0x12345678 저장 시:
주소:  0x00  0x01  0x02  0x03
값:    0x78  0x56  0x34  0x12
       ↑ 최하위 바이트가 가장 낮은 주소
```

#### Motorola 68000 (Big-endian)

```
1979: 68000 출시 - Big-endian 채택
Apple Macintosh, Amiga, Atari ST에 사용

0x12345678 저장 시:
주소:  0x00  0x01  0x02  0x03
값:    0x12  0x34  0x56  0x78
       ↑ 최상위 바이트가 가장 낮은 주소
```

#### MIPS (양쪽 지원)

```
1985: MIPS R2000 출시
특징: Bi-endian - 부팅 시 엔디언 선택 가능

SGI 워크스테이션: Big-endian으로 운영
PlayStation 1/2: Little-endian으로 운영
```

#### ARM (양쪽 지원, 기본 Little-endian)

```
1985: ARM1 출시 - Little-endian 기본
2000년대 이후: Bi-endian 지원하지만 Little-endian이 사실상 표준

iPhone, Android 기기: 모두 Little-endian
```

---

## 2. 현대 아키텍처에서의 엔디언 동작

### x86/x86-64 (Intel, AMD)

**항상 Little-endian**. 변경 불가능.

```c
// x86에서 0x12345678을 메모리에 저장하면
uint32_t value = 0x12345678;
// 메모리 덤프: 78 56 34 12
```

**장점:**
- 포인터 캐스팅이 자연스러움
- 가변 길이 정수 처리 용이

```c
uint32_t big = 0x12345678;
uint16_t *small = (uint16_t *)&big;
// *small = 0x5678 (하위 16비트를 그대로 읽음)
```

### ARM (ARMv7, ARMv8/AArch64)

**Bi-endian이지만 실질적으로 Little-endian 세상**

```
ARMv8-A 상태:
- 기본: Little-endian (EL0, EL1, EL2, EL3 모두)
- Big-endian 지원: SCTLR 레지스터의 EE/E0E 비트로 설정 가능
- 현실: iOS, Android, Linux 모두 Little-endian 사용
```

**ARM의 특이한 기능 - REV 명령어:**

```asm
// ARM에서 바이트 순서 뒤집기
REV W0, W1    // 32비트 엔디언 스왑
REV16 W0, W1  // 16비트 단위로 스왑
```

### MIPS

**설정에 따라 달라지는 Bi-endian**

```
Big-endian 모드 (BE=1):
- 네트워크 장비 (Cisco 라우터 등)
- SGI 워크스테이션

Little-endian 모드 (BE=0):
- PlayStation
- Windows CE 기기
- 대부분의 임베디드 시스템
```

### RISC-V (최신 아키텍처)

**기본 Little-endian, Big-endian은 확장으로 지원**

```
RISC-V 설계 철학:
"Little-endian을 기본으로 하되,
 필요한 경우 Big-endian 확장 가능"

실제로 거의 모든 RISC-V 구현체가 Little-endian
```

### PowerPC / POWER

**역사적으로 Big-endian, 현재는 선택 가능**

```
PowerPC 역사:
1992-2006: Apple Mac에서 Big-endian
2006 이후: Apple은 Intel로 전환
현재 IBM POWER: Little-endian Linux 지원 (ppc64le)
```

---

## 3. Network Byte Order가 적용되는 실제 코드

### 개념 복습

```
Network Byte Order = Big-endian (RFC 1700)
Host Byte Order = 시스템마다 다름

네트워크 통신 시:
Host → Network: htons(), htonl()
Network → Host: ntohs(), ntohl()
```

### C 언어

```c
#include <stdio.h>
#include <stdint.h>
#include <arpa/inet.h>  // Unix/Linux
// Windows: #include <winsock2.h>

int main() {
    // 포트 번호 변환 (16비트)
    uint16_t host_port = 8080;
    uint16_t net_port = htons(host_port);

    printf("Host order: 0x%04X\n", host_port);  // 0x1F90
    printf("Network order: 0x%04X\n", net_port); // Big-endian

    // IP 주소 변환 (32비트)
    uint32_t host_ip = 0xC0A80001;  // 192.168.0.1
    uint32_t net_ip = htonl(host_ip);

    // 역변환
    uint16_t back_to_host = ntohs(net_port);
    printf("Back to host: %d\n", back_to_host);  // 8080

    return 0;
}
```

**실제 소켓 프로그래밍 예제:**

```c
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

int create_server(int port) {
    int sockfd = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in addr;
    addr.sin_family = AF_INET;
    addr.sin_port = htons(port);        // 포트: 반드시 변환!
    addr.sin_addr.s_addr = INADDR_ANY;  // 0.0.0.0 - 이미 네트워크 순서

    bind(sockfd, (struct sockaddr *)&addr, sizeof(addr));
    listen(sockfd, 5);

    return sockfd;
}

// 커스텀 프로토콜 메시지 전송
struct message {
    uint32_t type;
    uint32_t length;
    char data[256];
};

void send_message(int sockfd, struct message *msg) {
    // 네트워크 바이트 순서로 변환
    uint32_t net_type = htonl(msg->type);
    uint32_t net_length = htonl(msg->length);

    send(sockfd, &net_type, sizeof(net_type), 0);
    send(sockfd, &net_length, sizeof(net_length), 0);
    send(sockfd, msg->data, msg->length, 0);
}
```

### Go 언어

```go
package main

import (
    "encoding/binary"
    "fmt"
    "net"
)

func main() {
    // Go의 encoding/binary 패키지 사용

    // Big-endian (Network byte order)
    buf := make([]byte, 4)
    binary.BigEndian.PutUint32(buf, 0x12345678)
    fmt.Printf("Big-endian: % X\n", buf)  // 12 34 56 78

    // Little-endian
    binary.LittleEndian.PutUint32(buf, 0x12345678)
    fmt.Printf("Little-endian: % X\n", buf)  // 78 56 34 12

    // 네트워크 프로토콜 구현 예
    writeNetworkPacket()
}

// TCP 패킷 헤더 작성 예제
func writeNetworkPacket() {
    packet := make([]byte, 8)

    // 메시지 타입 (2바이트) - Network byte order
    binary.BigEndian.PutUint16(packet[0:2], 0x0001)

    // 페이로드 길이 (4바이트) - Network byte order
    binary.BigEndian.PutUint32(packet[2:6], 1024)

    // 플래그 (2바이트) - Network byte order
    binary.BigEndian.PutUint16(packet[6:8], 0x8000)

    fmt.Printf("Packet: % X\n", packet)
}

// 실제 TCP 서버 예제
func tcpServer() {
    listener, _ := net.Listen("tcp", ":8080")
    conn, _ := listener.Accept()

    // 4바이트 길이 헤더 읽기
    header := make([]byte, 4)
    conn.Read(header)

    // Network byte order에서 변환
    length := binary.BigEndian.Uint32(header)

    // 본문 읽기
    body := make([]byte, length)
    conn.Read(body)
}
```

### Python

```python
import struct
import socket

# struct 모듈의 포맷 문자
# '>' : Big-endian (Network byte order)
# '<' : Little-endian
# '!' : Network byte order (= Big-endian)
# '@' : Native byte order

def endian_demo():
    value = 0x12345678

    # Big-endian 패킹
    big = struct.pack('>I', value)
    print(f"Big-endian: {big.hex()}")  # 12345678

    # Little-endian 패킹
    little = struct.pack('<I', value)
    print(f"Little-endian: {little.hex()}")  # 78563412

    # Network byte order (권장)
    network = struct.pack('!I', value)
    print(f"Network order: {network.hex()}")  # 12345678

def socket_example():
    """실제 소켓 프로그래밍 예제"""

    # 포트 변환 (C의 htons와 동일)
    port = 8080
    net_port = socket.htons(port)
    print(f"Port {port} -> Network: {net_port}")

    # IP 주소 변환 (C의 htonl과 동일)
    ip = 0xC0A80001  # 192.168.0.1
    net_ip = socket.htonl(ip)

    # inet_aton/inet_ntoa도 자동으로 처리
    packed_ip = socket.inet_aton("192.168.0.1")
    print(f"Packed IP: {packed_ip.hex()}")  # c0a80001

def protocol_example():
    """커스텀 바이너리 프로토콜 예제"""

    # 메시지 구조: [type:2][length:4][data:N]
    msg_type = 1
    data = b"Hello, Network!"
    length = len(data)

    # 헤더 패킹 (Network byte order)
    header = struct.pack('!HI', msg_type, length)
    packet = header + data

    print(f"Packet: {packet.hex()}")

    # 언패킹
    msg_type, length = struct.unpack('!HI', packet[:6])
    data = packet[6:6+length]
    print(f"Type: {msg_type}, Length: {length}, Data: {data}")

if __name__ == "__main__":
    endian_demo()
    socket_example()
    protocol_example()
```

### Rust

```rust
use std::io::{Read, Write};
use std::net::TcpStream;

fn main() {
    endian_demo();
}

fn endian_demo() {
    let value: u32 = 0x12345678;

    // Big-endian (Network byte order)
    let big_bytes = value.to_be_bytes();
    println!("Big-endian: {:02X?}", big_bytes);  // [12, 34, 56, 78]

    // Little-endian
    let little_bytes = value.to_le_bytes();
    println!("Little-endian: {:02X?}", little_bytes);  // [78, 56, 34, 12]

    // 역변환
    let from_big = u32::from_be_bytes(big_bytes);
    let from_little = u32::from_le_bytes(little_bytes);

    println!("From big: 0x{:08X}", from_big);
    println!("From little: 0x{:08X}", from_little);
}

fn send_network_message(stream: &mut TcpStream, msg_type: u16, data: &[u8]) {
    // 메시지 타입 (Network byte order)
    stream.write_all(&msg_type.to_be_bytes()).unwrap();

    // 데이터 길이 (Network byte order)
    let length = data.len() as u32;
    stream.write_all(&length.to_be_bytes()).unwrap();

    // 데이터 본문
    stream.write_all(data).unwrap();
}

fn receive_network_message(stream: &mut TcpStream) -> (u16, Vec<u8>) {
    // 메시지 타입 읽기
    let mut type_buf = [0u8; 2];
    stream.read_exact(&mut type_buf).unwrap();
    let msg_type = u16::from_be_bytes(type_buf);

    // 길이 읽기
    let mut len_buf = [0u8; 4];
    stream.read_exact(&mut len_buf).unwrap();
    let length = u32::from_be_bytes(len_buf) as usize;

    // 데이터 읽기
    let mut data = vec![0u8; length];
    stream.read_exact(&mut data).unwrap();

    (msg_type, data)
}
```

### 주의사항과 베스트 프랙티스

```
✅ DO:
- 네트워크 전송 시 항상 htonl/htons 또는 BigEndian 사용
- 프로토콜 문서에 바이트 순서 명시
- 파일 포맷에도 엔디언 명시 (예: BMP는 Little-endian)

❌ DON'T:
- 바이트 순서 변환 없이 구조체 직접 전송
- 플랫폼 기본 엔디언에 의존
- 문자열을 정수처럼 취급 (문자열은 엔디언 영향 없음)
```

---

## 4. 걸리버 여행기와 논문의 구조 비교

Danny Cohen의 "On Holy Wars and a Plea for Peace"는 걸리버 여행기의 구조를 의도적으로 차용했습니다.

### 서사 구조 비교

| 요소 | 걸리버 여행기 (1726) | Cohen의 논문 (1980) |
|------|---------------------|---------------------|
| **분쟁의 원인** | 달걀을 어느 쪽에서 깨느냐 | 바이트를 어느 쪽부터 저장하느냐 |
| **진영** | Big-Endians vs Little-Endians | Big-Endian CPU vs Little-Endian CPU |
| **분쟁의 본질** | 사소한 의식 문제 | 사소한 구현 세부사항 |
| **결과** | 전쟁, 학살, 망명 | 호환성 문제, 표준 전쟁 |
| **풍자 대상** | 종교 전쟁 (가톨릭 vs 프로테스탄트) | 기술 논쟁의 과열 |
| **해결책** | 제시되지 않음 (풍자 목적) | Network Byte Order 제안 |

### 문학적 장치 비교

#### 걸리버 여행기에서의 풍자

```
"이 논쟁으로 인해 여섯 번의 반란이 일어났고,
한 황제는 목숨을 잃었으며 다른 황제는 왕관을 잃었다.
이 내전들에서 11,000명 이상이
달걀의 큰 쪽 끝을 깨느니 차라리 죽겠다며 처형당했다."
- 걸리버 여행기, 제1부
```

**스위프트의 메시지**: 종교의 핵심 교리가 아닌 사소한 의식 차이로 사람을 죽이는 것은 미친 짓이다.

#### Cohen 논문에서의 풍자

```
"이 주제에 대한 논쟁은 종교적 열정을 동반한다.
마치 영혼의 구원이 걸린 것처럼...
그러나 잠시 멈추고 생각해보자.
우리가 정말 중요한 것을 위해 싸우고 있는가?"
- On Holy Wars and a Plea for Peace (의역)
```

**Cohen의 메시지**: 어느 엔디언이 "올바른지" 논쟁하는 것은 무의미하다. 표준을 정하고 따르면 된다.

### 해결책의 차이

| 작품 | 해결책 | 접근 방식 |
|------|--------|-----------|
| 걸리버 여행기 | 없음 | 인간 본성의 어리석음을 드러내는 것이 목적 |
| Cohen 논문 | Network Byte Order | 실용적 해결책 제시 + 풍자 |

### 역사적 영향 비교

```
걸리버 여행기 (1726)
    │
    ├─→ 문학: 풍자 소설의 고전으로 자리잡음
    │
    └─→ 언어: "Big-Endian", "Little-Endian" 용어 창조
              (원래는 정치/종교 풍자 용어)
                    │
                    ▼
Cohen 논문 (1980)
    │
    ├─→ 기술: 용어를 컴퓨터 과학에 도입
    │
    ├─→ 표준: Network Byte Order 개념 확립
    │         (RFC 1700에 공식화)
    │
    └─→ 문화: 기술 문서에 유머를 접목한 선례
              (이후 RFC 1149 "IP over Avian Carriers" 등)
```

### 두 작품의 공통 메시지

> **"인간(과 엔지니어)은 본질적이지 않은 것에 과도하게 집착하는 경향이 있다."**

걸리버 여행기는 이를 비극으로 그렸고, Cohen은 이를 해결 가능한 기술 문제로 재해석했습니다.

---

## 참고 자료

- Danny Cohen, "On Holy Wars and a Plea for Peace", IEEE Computer, 1981
- Jonathan Swift, "Gulliver's Travels", 1726
- RFC 1700 - Assigned Numbers (Network Byte Order 정의)
- Intel 64 and IA-32 Architectures Software Developer's Manual
- ARM Architecture Reference Manual
