---
layout: default
title: 현대 아키텍처의 엔디언
parent: 걸리버 여행기 원작에 대해
grand_parent: 잡동사니
nav_order: 4
---

# 현대 아키텍처에서의 엔디언 동작

x86, ARM, MIPS, RISC-V, PowerPC 등 현대 CPU 아키텍처에서의 엔디언 동작을 살펴봅니다.

---

## x86/x86-64 (Intel, AMD)

**항상 Little-endian**. 변경 불가능.

```c
// x86에서 0x12345678을 메모리에 저장하면
uint32_t value = 0x12345678;
// 메모리 덤프: 78 56 34 12
```

**장점:**
- 포인터 캐스팅이 자연스러움
- 가변 길이 정수 처리 용이

```c
uint32_t big = 0x12345678;
uint16_t *small = (uint16_t *)&big;
// *small = 0x5678 (하위 16비트를 그대로 읽음)
```

---

## ARM (ARMv7, ARMv8/AArch64)

**Bi-endian이지만 실질적으로 Little-endian 세상**

```
ARMv8-A 상태:
- 기본: Little-endian (EL0, EL1, EL2, EL3 모두)
- Big-endian 지원: SCTLR 레지스터의 EE/E0E 비트로 설정 가능
- 현실: iOS, Android, Linux 모두 Little-endian 사용
```

**ARM의 특이한 기능 - REV 명령어:**

```asm
// ARM에서 바이트 순서 뒤집기
REV W0, W1    // 32비트 엔디언 스왑
REV16 W0, W1  // 16비트 단위로 스왑
```

---

## MIPS

**설정에 따라 달라지는 Bi-endian**

```
Big-endian 모드 (BE=1):
- 네트워크 장비 (Cisco 라우터 등)
- SGI 워크스테이션

Little-endian 모드 (BE=0):
- PlayStation
- Windows CE 기기
- 대부분의 임베디드 시스템
```

---

## RISC-V (최신 아키텍처)

**기본 Little-endian, Big-endian은 확장으로 지원**

```
RISC-V 설계 철학:
"Little-endian을 기본으로 하되,
 필요한 경우 Big-endian 확장 가능"

실제로 거의 모든 RISC-V 구현체가 Little-endian
```

---

## PowerPC / POWER

**역사적으로 Big-endian, 현재는 선택 가능**

```
PowerPC 역사:
1992-2006: Apple Mac에서 Big-endian
2006 이후: Apple은 Intel로 전환
현재 IBM POWER: Little-endian Linux 지원 (ppc64le)
```

---

## 참고 자료

- Intel 64 and IA-32 Architectures Software Developer's Manual
- ARM Architecture Reference Manual
- MIPS Architecture Reference Manual
- RISC-V Specification
